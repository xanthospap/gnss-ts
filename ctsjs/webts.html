<!DOCTYPE html>
<html lang="en">

<head><title>Time Series Plot</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
    <link href='https://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css' rel='stylesheet' type='text/css'>
    <link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' rel='stylesheet' type='text/css'>

    <script src='https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.0/d3.min.js' charset='utf-8'></script>
    <script src="http://d3js.org/d3.v4.min.js"></script>

    <style type="text/css">
        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 3.5px;
        }
    </style>
</head>

<body>
<div class='container-fluid'>
    <div class='row'>
        <h2 id='header-string'>Position Time-Series for station </h2>
    </div>
    
    <div class='row'>
        <div class='btn-group'>
            <div class='btn-group'>
                <button type='button' class='btn btn-primary dropdown-toggle' data-toggle='dropdown'>
                    Show <span class='caret'></span></button>
                <ul class="dropdown-menu" role="menu">
                    <li><a href='#' onclick='plot_raw();'>Time-Series Plot</a></li>
                    <li><a href='#' onclick='plot_residuals();'>Residual Plot</a></li>
                </ul>
            </div>
            <div class='btn-group'>
                <button type='button' class='btn btn-primary dropdown-toggle' data-toggle='dropdown'>
                    DateTime Format <span class='caret'></span></button>
                <ul class="dropdown-menu" role="menu">
                    <li><a href='#' onclick='to_ymdhms();'>Year-Month-Day</a></li>
                    <li><a href='#' onclick='to_mjd();'>Modified Julian Date</a></li>
                    <li><a href='#' onclick='to_gpsw();'>GPS Week</a></li>
                </ul>
            </div>
            <button type='button' class='btn btn-primary inactive' id='outlier-btn' onclick='plot_raw_no_outliers();'>Filter Outliers</button>
            <button type='button' class='btn btn-primary inactive' id='chart-btn'>Line Plot</button>
            <button type='button' class='btn btn-primary inactive' id='events-btn'>Show Events</button>
            <button type='button' class='btn btn-primary inactive' id='model-btn' onclick='plot_models();'>Show Model</button>
        </div>
    </div><!-- row-->

    <!-- the 3 plots -->
    <div id="North-Plot"></div>
    <div id="East-Plot"></div>
    <div id="Up-Plot"></div>

</div><!-- container-fluid -->

<script>

function deepCopy(arr) {
    var out = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        var item = arr[i];
        var obj  = {};
        for (var k in item) { obj[k] = item[k]; }
        out.push(obj);
    }
    return out;
}

/*
** Convert a (double) Modified Julian Day to GPS week and seconds of week.
** The function returns a fractional gps week
*/
function mjd_to_gps(dmjd)
{
    var mjd  = Math.floor(dmjd);
    var fmjd = dmjd - Math.floor(dmjd);
    var gps_week = (mjd - 44244)/7;
    var sec_of_week = ((mjd-44244)-gps_week*7+fmjd)*86400;
    return gps_week + sec_of_week / (7*86400);
}

/*
** Convert a (double) Modified Julian Day to a string of type:
** YYYY-MM-DD HH:MM:SS
*/
function mjd_to_ymdhms(dmjd)
{
    var mjd  = Math.floor(dmjd);
    var fmjd = dmjd - Math.floor(dmjd);
    var month_day = [
        [0, 0],
        [31, 31],
        [59, 60],
        [90, 91],
        [120, 121],
        [151, 152],
        [181, 182],
        [212, 213],
        [243, 244],
        [273, 274],
        [304, 305],
        [334, 335],
        [365, 366]
    ];
    var days_fr_jan1_1901 = mjd - 15385;
    var num_four_yrs = parseInt(days_fr_jan1_1901/1461);
    var years_so_far = 1901 + parseInt(4*num_four_yrs);
    var days_left = days_fr_jan1_1901 - 1461*num_four_yrs;
    var delta_yrs = parseInt(days_left/365) - parseInt(days_left/1460);

    var year = years_so_far + delta_yrs;
    var yday = days_left - 365*delta_yrs + 1;
    var hour = parseInt(fmjd*24.0);
    var minute = parseInt(fmjd*1440.0 - hour*60.0);
    var second = parseInt(fmjd*86400.0 - hour*3600.0 - minute*60.0);
    var leap = 0;
    if (parseInt(year%4) == 0) leap = 1;
    var guess = parseInt(yday*0.032);
    var more = (( yday - month_day[guess+1][leap] ) > 0);
    var month = guess + more + 1;
    var mday = yday - month_day[guess+more][leap];

    return parseInt(year).toString() +
        "-" + parseInt(month).toString() +
        "-" + parseInt(mday).toString() +
        " " + parseInt(hour).toString() +
        ":" + parseInt(minute).toString() +
        ":" + parseInt(second).toString();
}

var margin = {top: 20, right: 80, bottom: 30, left: 50},
    width  = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

// store here the min and max values of the x-axis as mjd values.
var g_min_mjd, g_max_mjd;

// axis setup functions/variables
var dateFormat = d3.time.format("%Y-%m-%d %H:%M:%S");
var x = d3.scaleLinear().range([0, width]); // v4.x
var xAxis  = d3.axisBottom(x);
var yN     = d3.scaleLinear().range([height, 0]);
var yE     = d3.scaleLinear().range([height, 0]);
var yU     = d3.scaleLinear().range([height, 0]);
var yAxisN = d3.axisLeft(yN); // v4.x
var yAxisE = d3.axisLeft(yE); // v4.x
var yAxisU = d3.axisLeft(yU); // v4.x

// simple D3 line functions, to plot arrays of objects of type
// {"t":...,"val":...}; normally used to plot the model line (per component)
var nline = d3.svg.line()
    .x(function(d) { return x(d.t); })
    .y(function(d) { return yN(d.val); });
var eline = d3.svg.line()
    .x(function(d) { return x(d.t); })
    .y(function(d) { return yE(d.val); });
var uline = d3.svg.line()
    .x(function(d) { return x(d.t); })
    .y(function(d) { return yU(d.val); });

var svgN = d3.select("#North-Plot").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var svgE = d3.select("#East-Plot").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var svgU = d3.select("#Up-Plot").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.json('dion.json', function(error, data) {
    if ( error ) throw error;
    
    // the actual data to plot is:
    pdata = data.data;

    // set x and y domains
    x.domain(d3.extent (pdata, function(d) { return d.epoch; }));
    yN.domain(d3.extent(pdata, function(d) { return d.north; }));
    yE.domain(d3.extent(pdata, function(d) { return d.east; }));
    yU.domain(d3.extent(pdata, function(d) { return d.up; }));
    
    // set (append) the x-axis in all three subplots
    svgN.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
    svgE.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
     svgU.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
      
    // set (append) the y-axis
    svgN.append("g")
        .attr("class", "y axis")
        .call(yAxisN)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("North (m)");
    svgE.append("g")
        .attr("class", "y axis")
        .call(yAxisE)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("East (m)");
    svgU.append("g")
        .attr("class", "y axis")
        .call(yAxisU)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Up (m)");
        
    // add the lines
    /*
    svgN.append("path")
        .datum(pdata)
        .attr("class", "line")
        .attr("d", raw_line);
    */
    svgN.selectAll(".dot")
        .data(pdata)
      .enter().append("circle")
        .attr("r", 3.0)
        .attr("cx", function(d) {return x(d.epoch);})
        .attr("cy", function(d) {return yN(d.north);})
        .attr("stroke", "blue")
        .attr("stroke-width", 0.3)
        .attr("fill", function(d) {
            return (d.flag_north.indexOf("o")>-1) ? "yellow" : "red" ;
        })
        .attr("class", function(d) {
            return (d.flag_north.indexOf("o")>-1)
                ? "data_pt outlier_pt"
                : "data_pt normal_pt" ;
        });
    svgE.selectAll(".dot")
        .data(pdata)
      .enter().append("circle")
        .attr("r", 3.0)
        .attr("cx", function(d) {return x(d.epoch);})
        .attr("cy", function(d) {return yE(d.east);})
        .attr("stroke", "blue")
        .attr("stroke-width", 0.3)
        .attr("fill", function(d) {
            return (d.flag_east.indexOf("o")>-1) ? "yellow" : "red" ;
        })
        .attr("class", function(d) {
            return (d.flag_east.indexOf("o")>-1)
                ? "data_pt outlier_pt"
                : "data_pt normal_pt" ;
        });
    svgU.selectAll(".dot")
        .data(pdata)
      .enter().append("circle")
        .attr("r", 3.0)
        .attr("cx", function(d) {return x(d.epoch);})
        .attr("cy", function(d) {return yU(d.up);})
        .attr("stroke", "blue")
        .attr("stroke-width", 0.3)
        .attr("fill", function(d) {
            return (d.flag_up.indexOf("o")>-1) ? "yellow" : "red" ;
        })
        .attr("class", function(d) {
            return (d.flag_up.indexOf("o")>-1)
                ? "data_pt outlier_pt"
                : "data_pt normal_pt" ;
        });

        // enable outlier button
        document.getElementById("outlier-btn").disabled = false;

        // assign blobal min/max mjd
        g_min_mjd = x.domain()[0];
        g_max_mjd = x.domain()[1];
});

/*
** This function will:
** 1. Remove all points (on all three svg's) that belong to the 'residual_pt'
**    class
*/
function plot_raw() {
    d3.json('dion.json', function(error, data) {
        if ( error ) throw error;
        
        // the actual data to plot is:
        pdata = data.data;

        // set x and y domains
        x.domain(d3.extent (pdata, function(d) { return d.epoch; }));
        yN.domain([0, 0]);
        yN.domain(d3.extent(pdata, function(d) { return d.north; }));
        yE.domain([0, 0]);
        yE.domain(d3.extent(pdata, function(d) { return d.east; }));
        yU.domain([0, 0]);
        yU.domain(d3.extent(pdata, function(d) { return d.up; }));
        
        // rescale y-axis
        svgN.selectAll(".y.axis").call(yAxisN);
        svgE.selectAll(".y.axis").call(yAxisE);
        svgU.selectAll(".y.axis").call(yAxisU);
        
        // remove outliers if any
        svgN.selectAll(".residual_pt").remove();
        svgE.selectAll(".residual_pt").remove();
        svgU.selectAll(".residual_pt").remove();
    
        // add the data points
        svgN.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", 3.0)
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.north);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", function(d) {
                if (d.flag_north.indexOf("o")>-1) return "yellow";
                return "red";
            })
            .attr("class", function(d) {
                if (d.flag_north.indexOf("o")>-1) return "outlier_pt data_pt";
                else return "normal_pt data_pt";
            });
        svgE.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", 3.0)
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.east);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", function(d) {
                if (d.flag_east.indexOf("o")>-1) return "yellow";
                return "red";
            })
            .attr("class", function(d) {
                if (d.flag_east.indexOf("o")>-1) return "outlier_pt data_pt";
                else return "normal_pt data_pt";
            });
        svgU.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", 3.0)
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.up);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", function(d) {
                if (d.flag_up.indexOf("o")>-1) return "yellow";
                return "red";
            })
        .attr("class", function(d) {
            if (d.flag_up.indexOf("o")>-1) return "outlier_pt data_pt";
            else return "normal_pt data_pt";
        });
    });
    // enable outlier button
    document.getElementById("outlier-btn").disabled = false;
}

/*
** Read in a json time-series file and plot residuals (North, East and Up).
** The function will remove any points/elements of the plots, belonging to
** the class 'data_pt'. All points ploted (on the svg's) will be of class
** 'residual_pt'
** The plots will be re-scaled and outliers will be filtered.
** The y-axis will be set to MilliMeters.
** This function will also set the 'Filter Outliers' button to disabled state.
** TODO Rename the y-axis
*/
function plot_residuals() {
    d3.json('dion.json', function(error, data) {
        if ( error ) throw error;
        pdata = data.data;
        
        // set x and y domains
        x.domain(d3.extent (pdata, function(d) { return d.epoch; }));
        yN.domain([0, 0]);
        yN.domain(d3.extent(pdata, function(d) {
            return (d.flag_north.indexOf("o")>-1) ? 0 : d.res_north*1000;
        }));
        yE.domain([0, 0]);
        yE.domain(d3.extent(pdata, function(d) {
            return (d.flag_east.indexOf("o")>-1) ? 0 : d.res_east*1000;
        }));
        yU.domain([0, 0]);
        yU.domain(d3.extent(pdata, function(d) {
            return (d.flag_up.indexOf("o")>-1) ? 0 : d.res_up*1000;
        }));
        
        // rescale y-axis
        svgN.selectAll(".y.axis").call(yAxisN);
        svgE.selectAll(".y.axis").call(yAxisE);
        svgU.selectAll(".y.axis").call(yAxisU);

        // remove any data points belonging to the class 'data_pt'
        svgN.selectAll(".data_pt").remove();
        svgE.selectAll(".data_pt").remove();
        svgU.selectAll(".data_pt").remove();
        
        // plot the residuals as points (circles)
        svgN.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", function(d) {
                return (d.flag_north.indexOf("o")>-1) ? 0 : 3.0;
            })
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.res_north * 1000);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", "red")
            .attr("class", function(d) {
                return (d.flag_north.indexOf("o")>-1)
                    ? "outlier_pt residual_pt"
                    : "normal_pt residual_pt";
            });
        svgE.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", function(d) {
                return (d.flag_east.indexOf("o")>-1) ? 0 : 3.0;
            })
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yE(d.res_east * 1000);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", "red")
            .attr("class", function(d) {
                return (d.flag_east.indexOf("o")>-1)
                    ? "outlier_pt residual_pt"
                    : "normal_pt residual_pt";
            });
        svgU.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", function(d) {
                return (d.flag_up.indexOf("o")>-1) ? 0 : 3.0;
            })
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yU(d.res_up * 1000);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", "red")
            .attr("class", function(d) {
                return (d.flag_up.indexOf("o")>-1)
                    ? "outlier_pt residual_pt"
                    : "normal_pt residual_pt";
            });
        
    });

    // disable outlier button
    document.getElementById("outlier-btn").disabled = true;
}

/*
** This function will:
** 1. Remove all points (on all three svg's) tha belong to the 'outlier_pt'
**    class
** 2. Rescale the y-axis (to not include the above points)
** 3. Re-scale and re-plot all points belonging to the 'normal_pt' class
*/
function plot_raw_no_outliers() {
    // Get the data again
    d3.json('dion.json', function(error, data) {
        if ( error ) throw error;
        pdata = data.data;

        // set x and y domains
        x.domain(d3.extent (pdata, function(d) { return d.epoch; }));
        yN.domain([0, 0]);
        yE.domain([0, 0]);
        yU.domain([0, 0]);
        yN.domain(d3.extent(pdata, function(d) {
            return (d.flag_north.indexOf("o")>-1) ? 0 : d.north;
        }));
        yE.domain(d3.extent(pdata, function(d) { 
            return (d.flag_east.indexOf("o")>-1) ? 0 : d.east;
        }));
        yU.domain(d3.extent(pdata, function(d) { 
            return (d.flag_up.indexOf("o")>-1) ? 0 : d.up;
        }));
        
        // rescale y-axis
        svgN.selectAll(".y.axis").call(yAxisN);
        svgE.selectAll(".y.axis").call(yAxisE);
        svgU.selectAll(".y.axis").call(yAxisU);
    
        // remove points that belong to the 'outlier_pt' class
        svgN.selectAll(".outlier_pt").remove();
        svgE.selectAll(".outlier_pt").remove();
        svgU.selectAll(".outlier_pt").remove();
        
        // re-scale points that belong to the 'normal_pt' class
        svgN.selectAll(".data_pt")
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.north);});
        svgE.selectAll(".data_pt")
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yE(d.east);});
        svgU.selectAll(".data_pt")
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yU(d.up);});
    });

    // if we also have the model lines, we need to rescale them!
    if ( svgN.select(".model_line").empty() ) {
        console.log("empty selection");
    } else {
        console.log("shit! rescaling model line");
        // store model points here
        var xdata, ydata, zdata;
        // Get the data
        d3.json('model.json', function(error, data) {
            if ( error ) throw error;
            
            // compute the model points/canvas
            xdata = make_model(data.model_x, g_min_mjd, g_max_mjd, 1);
            ydata = make_model(data.model_y, g_min_mjd, g_max_mjd, 1);
            zdata = make_model(data.model_z, g_min_mjd, g_max_mjd, 1);

            // re-scale the model-line (if any)
            svgN.select(".model_line").attr("d", nline(xdata));
            svgE.select(".model_line").attr("d", eline(ydata));
            svgU.select(".model_line").attr("d", uline(zdata));
        });
    }
}

/*
** Given a "model" object (as read off fro a corrsponding json file),
** compute the values of the model for values in
** range [from,to] with a step = step.
** The values are returned as an array of objects of type:
** [...{"t":...,"val":...}...] so that they can be ploted via the [neu]line
** functions
*/
function make_model(mod, from, to, step)
{
    var data = [];
    var value = 0;
    var ref_t = mod.reference_epoch;

    for (var t = from; t <= to; t += step) {
        var dt = t - ref_t;
        value  = mod.const_term;
        value += mod.velocity*dt/365.25;
        for (var comp in mod.harmonics) {
            if (t>=mod.harmonics[comp].from && t<mod.harmonics[comp].to)
            {
                var angular_frequency = 2*Math.PI/mod.harmonics[comp].period;
                value += mod.harmonics[comp].in_phase*Math.cos(angular_frequency*dt);
                value += mod.harmonics[comp].out_of_phase*Math.sin(angular_frequency*dt);
            }
        }
        data.push({"t":t, "val":value});
    }
    return data;
}

/*
** Read coordinate time-series model(s) off from a corresponding json file,
** and plot the models (one per component). The plotted lines will belong to a
** class(es) named "line model_line"
*/
function plot_models()
{
    // store model points here
    var xdata, ydata, zdata;
    
    // Get the data
    d3.json('model.json', function(error, data) {
        if ( error ) throw error;
        
        // compute the model points/canvas
        xdata = make_model(data.model_x, g_min_mjd, g_max_mjd, 1);
        ydata = make_model(data.model_y, g_min_mjd, g_max_mjd, 1);
        zdata = make_model(data.model_z, g_min_mjd, g_max_mjd, 1);

        // append the model as line
        svgN.append("path")
            .datum(xdata)
            .attr("class", "line model_line")
            .attr("d", nline);
        svgE.append("path")
            .datum(ydata)
            .attr("class", "line model_line")
            .attr("d", eline);
        svgU.append("path")
            .datum(zdata)
            .attr("class", "line model_line")
            .attr("d", uline);
    });
}

/*
** Attach the x axis to a datetime scale in the domain [g_min_mjd,g_max_mjd]
** Note that nothing gets reploted!
*/
function to_ymdhms()
{
    x = d3.scaleTime().range([0, width]);
    min_ymd = mjd_to_ymdhms(g_min_mjd);
    max_ymd = mjd_to_ymdhms(g_max_mjd);
    // console.log("Min date:", min_ymd);
    // console.log("Max date:", max_ymd);
    x.domain([dateFormat.parse(min_ymd), dateFormat.parse(max_ymd)]);
    xAxis  = d3.axisBottom(x);
    
    // rescale x-axis
    svgN.selectAll(".x.axis").call(xAxis);
    svgE.selectAll(".x.axis").call(xAxis);
    svgU.selectAll(".x.axis").call(xAxis);
}
/*
** Attach the x axis to a datetime scale in the domain [g_min_mjd,g_max_mjd]
** Note that nothing gets reploted!
*/
function to_mjd()
{
    x = d3.scaleLinear().range([0, width]); // v4.x
    x.domain([g_min_mjd, g_max_mjd]);
    xAxis  = d3.axisBottom(x);
    
    // rescale x-axis
    svgN.selectAll(".x.axis").call(xAxis);
    svgE.selectAll(".x.axis").call(xAxis);
    svgU.selectAll(".x.axis").call(xAxis);
}
function to_gpsw()
{
    x = d3.scaleLinear().range([0, width]); // v4.x
    x.domain([mjd_to_gps(g_min_mjd), mjd_to_gps(g_max_mjd)]);
    xAxis  = d3.axisBottom(x);
    
    // rescale x-axis
    svgN.selectAll(".x.axis").call(xAxis);
    svgE.selectAll(".x.axis").call(xAxis);
    svgU.selectAll(".x.axis").call(xAxis);
}
</script>

</body>
</html>
