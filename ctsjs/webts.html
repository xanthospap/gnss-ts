<!DOCTYPE html>
<html lang="en">

<head><title>Time Series Plot</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
    <link href='https://netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css' rel='stylesheet' type='text/css'>
    <link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' rel='stylesheet' type='text/css'>

    <script src='https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.0/d3.min.js' charset='utf-8'></script>
    <script src="http://d3js.org/d3.v4.min.js"></script>

    <style type="text/css">
        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 3.5px;
        }
        .event_line {
            fill: none;
            stroke-width: 1.5px;
        }
        .jump_line {
            stroke: springgreen;
        }
        .velchg_line {
            stroke: turquoise;
        }
        .erthqk_line {
            stroke: peru;
        }
        .model_text {
            color: steelblue;
            text-align: left;
            font-family: Consolas, monospace, sans-serif;
            font-size: 12px;
        }
        .model-tooltip {
            position: absolute;
            text-align: center;
            width: 250px;
            height: 150px;
            padding: 1px;
            font: 11px sans-serif;
            background: lightsteelblue;
            border: 1px;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>

<body>
<div class='container-fluid'>
    <div class='row'>
        <h2 id='header-string'>Position Time-Series for station </h2>
    </div>

    <div class='row'>
        <div class='btn-group btn-group-lg'>
            <div class='btn-group'>
                <button type='button' class='btn btn-primary dropdown-toggle' data-toggle='dropdown'>
                    Show <span class='caret'></span></button>
                <ul class="dropdown-menu" role="menu">
                    <li><a href='#' onclick='plot_raw();'>Time-Series Plot</a></li>
                    <li><a href='#' onclick='plot_residuals();'>Residual Plot</a></li>
                </ul>
            </div>
            <div class='btn-group'>
                <button type='button' class='btn btn-primary dropdown-toggle' data-toggle='dropdown'>
                    DateTime Format <span class='caret'></span></button>
                <ul class="dropdown-menu" role="menu">
                    <li><a href='#' onclick='to_ymdhms();'>Year-Month-Day</a></li>
                    <li><a href='#' onclick='to_mjd();'>Modified Julian Date</a></li>
                    <li><a href='#' onclick='to_gpsw();'>GPS Week</a></li>
                </ul>
            </div>
        </div>
    </div><!-- row-->

    <div class='row'>
        <div class='btn-group btn-group-lg'>
            <div class="checkbox-inline">
                <input type="checkbox" id="outlier-btn" onclick="plot_raw_no_outliers();">
                <label for="outlier-btn"> Filter Outliers </label>
            </div>
            <div class="checkbox-inline">
                <input type="checkbox" id="events-btn" onclick="plot_events();">
                <label for="events-btn"> Show Events </label>
            </div>
            <div class="checkbox-inline">
                <input type="checkbox" id="model-btn" onclick="plot_models();">
                <label for="model-btn"> Show Model </label>
            </div>
            <!--
            <div class="checkbox-inline">
                <input type="checkbox" id="model-info-btn" onclick="show_model_info();">
                <label for="model-info-btn"> Show Model Info</label>
            </div>
            -->
        </div>
    </div>

    <!-- the 3 plots -->
    <div class='col-md-12' id="North-Plot"></div>
    <div class='col-md-12' id="East-Plot"></div>
    <div class='col-md-12' id="Up-Plot"></div>

</div><!-- container-fluid -->

<script>

function deepCopy(arr) {
    var out = [];
    for (var i = 0, len = arr.length; i < len; i++) {
        var item = arr[i];
        var obj  = {};
        for (var k in item) { obj[k] = item[k]; }
        out.push(obj);
    }
    return out;
}

/*
** Convert a (double) Modified Julian Day to GPS week and seconds of week.
** The function returns a fractional gps week
*/
function mjd_to_gps(dmjd)
{
    var mjd  = Math.floor(dmjd);
    var fmjd = dmjd - Math.floor(dmjd);
    var gps_week = (mjd - 44244)/7;
    var sec_of_week = ((mjd-44244)-gps_week*7+fmjd)*86400;
    return gps_week + sec_of_week / (7*86400);
}

/*
** Convert a (double) Modified Julian Day to a string of type:
** YYYY-MM-DD HH:MM:SS
*/
function mjd_to_ymdhms(dmjd)
{
    var mjd  = Math.floor(dmjd);
    var fmjd = dmjd - Math.floor(dmjd);
    var month_day = [
        [0, 0],
        [31, 31],
        [59, 60],
        [90, 91],
        [120, 121],
        [151, 152],
        [181, 182],
        [212, 213],
        [243, 244],
        [273, 274],
        [304, 305],
        [334, 335],
        [365, 366]
    ];
    var days_fr_jan1_1901 = mjd - 15385;
    var num_four_yrs = parseInt(days_fr_jan1_1901/1461);
    var years_so_far = 1901 + parseInt(4*num_four_yrs);
    var days_left = days_fr_jan1_1901 - 1461*num_four_yrs;
    var delta_yrs = parseInt(days_left/365) - parseInt(days_left/1460);

    var year = years_so_far + delta_yrs;
    var yday = days_left - 365*delta_yrs + 1;
    var hour = parseInt(fmjd*24.0);
    var minute = parseInt(fmjd*1440.0 - hour*60.0);
    var second = parseInt(fmjd*86400.0 - hour*3600.0 - minute*60.0);
    var leap = 0;
    if (parseInt(year%4) == 0) leap = 1;
    var guess = parseInt(yday*0.032);
    var more = (( yday - month_day[guess+1][leap] ) > 0);
    var month = guess + more + 1;
    var mday = yday - month_day[guess+more][leap];

    return parseInt(year).toString() +
        "-" + parseInt(month).toString() +
        "-" + parseInt(mday).toString() +
        " " + parseInt(hour).toString() +
        ":" + parseInt(minute).toString() +
        ":" + parseInt(second).toString();
}

var margin = {top: 20, right: 80, bottom: 30, left: 50},
    width  = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

// store here the min and max values of the x-axis as mjd values.
var g_min_mjd, g_max_mjd;

// axis setup functions/variables
var dateFormat = d3.time.format("%Y-%m-%d %H:%M:%S");
var x = d3.scaleLinear().range([0, width]); // v4.x
var xAxis  = d3.axisBottom(x);
var yN     = d3.scaleLinear().range([height, 0]);
var yE     = d3.scaleLinear().range([height, 0]);
var yU     = d3.scaleLinear().range([height, 0]);
var yAxisN = d3.axisLeft(yN); // v4.x
var yAxisE = d3.axisLeft(yE); // v4.x
var yAxisU = d3.axisLeft(yU); // v4.x

// simple D3 line functions, to plot arrays of objects of type
// {"t":...,"val":...}; normally used to plot the model line (per component)
var nline = d3.svg.line()
    .x(function(d) { return x(d.t); })
    .y(function(d) { return yN(d.val); });
var eline = d3.svg.line()
    .x(function(d) { return x(d.t); })
    .y(function(d) { return yE(d.val); });
var uline = d3.svg.line()
    .x(function(d) { return x(d.t); })
    .y(function(d) { return yU(d.val); });

var svgN = d3.select("#North-Plot").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var svgE = d3.select("#East-Plot").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var svgU = d3.select("#Up-Plot").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.json('tuc2.json', function(error, data) {
    if ( error ) throw error;
    
    // the actual data to plot is:
    pdata = data.data;

    // set x and y domains
    x.domain(d3.extent (pdata, function(d) { return d.epoch; }));
    yN.domain(d3.extent(pdata, function(d) { return d.north; }));
    yE.domain(d3.extent(pdata, function(d) { return d.east; }));
    yU.domain(d3.extent(pdata, function(d) { return d.up; }));
    
    // set (append) the x-axis in all three subplots
    svgN.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
    svgE.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
     svgU.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
      
    // set (append) the y-axis
    svgN.append("g")
        .attr("class", "y axis")
        .call(yAxisN)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("North (m)");
    svgE.append("g")
        .attr("class", "y axis")
        .call(yAxisE)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("East (m)");
    svgU.append("g")
        .attr("class", "y axis")
        .call(yAxisU)
      .append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("Up (m)");
        
    // add the lines
    svgN.selectAll(".dot")
        .data(pdata)
      .enter().append("circle")
        .attr("r", 3.0)
        .attr("cx", function(d) {return x(d.epoch);})
        .attr("cy", function(d) {return yN(d.north);})
        .attr("stroke", "blue")
        .attr("stroke-width", 0.3)
        .attr("fill", function(d) {
            return (d.flag_north.indexOf("o")>-1) ? "yellow" : "red" ;
        })
        .attr("class", function(d) {
            return (d.flag_north.indexOf("o")>-1)
                ? "data_pt outlier_pt"
                : "data_pt normal_pt" ;
        });
    svgE.selectAll(".dot")
        .data(pdata)
      .enter().append("circle")
        .attr("r", 3.0)
        .attr("cx", function(d) {return x(d.epoch);})
        .attr("cy", function(d) {return yE(d.east);})
        .attr("stroke", "blue")
        .attr("stroke-width", 0.3)
        .attr("fill", function(d) {
            return (d.flag_east.indexOf("o")>-1) ? "yellow" : "red" ;
        })
        .attr("class", function(d) {
            return (d.flag_east.indexOf("o")>-1)
                ? "data_pt outlier_pt"
                : "data_pt normal_pt" ;
        });
    svgU.selectAll(".dot")
        .data(pdata)
      .enter().append("circle")
        .attr("r", 3.0)
        .attr("cx", function(d) {return x(d.epoch);})
        .attr("cy", function(d) {return yU(d.up);})
        .attr("stroke", "blue")
        .attr("stroke-width", 0.3)
        .attr("fill", function(d) {
            return (d.flag_up.indexOf("o")>-1) ? "yellow" : "red" ;
        })
        .attr("class", function(d) {
            return (d.flag_up.indexOf("o")>-1)
                ? "data_pt outlier_pt"
                : "data_pt normal_pt" ;
        });

        // check/uncheck buttons button
        document.getElementById("outlier-btn").checked = false;
        document.getElementById("model-btn").checked   = false;
        document.getElementById("events-btn").checked  = false;
        // enable/disable buttons button
        document.getElementById("outlier-btn").disabled = false;
        document.getElementById("model-btn").disabled   = false;
        document.getElementById("events-btn").disabled  = false;

        // assign blobal min/max mjd
        g_min_mjd = x.domain()[0];
        g_max_mjd = x.domain()[1];
});

/*
** This function will:
** 1. Remove all points (on all three svg's) that belong to the 'residual_pt'
**    class
*/
function plot_raw() {
    
    d3.json('tuc2.json', function(error, data) {
        if ( error ) throw error;
        
        // the actual data to plot is:
        pdata = data.data;

        // set x and y domains
        x.domain(d3.extent (pdata, function(d) { return d.epoch; }));
        yN.domain([0, 0]);
        yN.domain(d3.extent(pdata, function(d) { return d.north; }));
        yE.domain([0, 0]);
        yE.domain(d3.extent(pdata, function(d) { return d.east; }));
        yU.domain([0, 0]);
        yU.domain(d3.extent(pdata, function(d) { return d.up; }));
        
        // rescale y-axis
        svgN.selectAll(".y.axis").call(yAxisN);
        svgE.selectAll(".y.axis").call(yAxisE);
        svgU.selectAll(".y.axis").call(yAxisU);
        
        // remove outliers if any
        svgN.selectAll(".residual_pt").remove();
        svgE.selectAll(".residual_pt").remove();
        svgU.selectAll(".residual_pt").remove();
    
        // add the data points
        svgN.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", 3.0)
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.north);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", function(d) {
                if (d.flag_north.indexOf("o")>-1) return "yellow";
                return "red";
            })
            .attr("class", function(d) {
                if (d.flag_north.indexOf("o")>-1) return "outlier_pt data_pt";
                else return "normal_pt data_pt";
            });
        svgE.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", 3.0)
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.east);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", function(d) {
                if (d.flag_east.indexOf("o")>-1) return "yellow";
                return "red";
            })
            .attr("class", function(d) {
                if (d.flag_east.indexOf("o")>-1) return "outlier_pt data_pt";
                else return "normal_pt data_pt";
            });
        svgU.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", 3.0)
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.up);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", function(d) {
                if (d.flag_up.indexOf("o")>-1) return "yellow";
                return "red";
            })
        .attr("class", function(d) {
            if (d.flag_up.indexOf("o")>-1) return "outlier_pt data_pt";
            else return "normal_pt data_pt";
        });
    });
    // enable/disable buttons button
    document.getElementById("outlier-btn").disabled = false;
    document.getElementById("model-btn").disabled   = false;
    document.getElementById("events-btn").disabled  = false;
}

/*
** Read in a json time-series file and plot residuals (North, East and Up).
** The function will remove any points/elements of the plots, belonging to
** the class 'data_pt'. All points ploted (on the svg's) will be of class
** 'residual_pt'
** The plots will be re-scaled and outliers will be filtered.
** The y-axis will be set to MilliMeters.
** This function will also set the 'Filter Outliers' button to disabled state.
** TODO Rename the y-axis
*/
function plot_residuals() {
    d3.json('tuc2.json', function(error, data) {
        if ( error ) throw error;
        pdata = data.data;
        
        // set x and y domains
        x.domain(d3.extent (pdata, function(d) { return d.epoch; }));
        yN.domain([0, 0]);
        yN.domain(d3.extent(pdata, function(d) {
            return (d.flag_north.indexOf("o")>-1) ? 0 : d.res_north*1000;
        }));
        yE.domain([0, 0]);
        yE.domain(d3.extent(pdata, function(d) {
            return (d.flag_east.indexOf("o")>-1) ? 0 : d.res_east*1000;
        }));
        yU.domain([0, 0]);
        yU.domain(d3.extent(pdata, function(d) {
            return (d.flag_up.indexOf("o")>-1) ? 0 : d.res_up*1000;
        }));
        
        // rescale y-axis
        svgN.selectAll(".y.axis").call(yAxisN);
        svgE.selectAll(".y.axis").call(yAxisE);
        svgU.selectAll(".y.axis").call(yAxisU);

        // remove any data points belonging to the class 'data_pt'
        svgN.selectAll(".data_pt").remove();
        svgE.selectAll(".data_pt").remove();
        svgU.selectAll(".data_pt").remove();
        
        // plot the residuals as points (circles)
        svgN.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", function(d) {
                return (d.flag_north.indexOf("o")>-1) ? 0 : 3.0;
            })
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.res_north * 1000);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", "red")
            .attr("class", function(d) {
                return (d.flag_north.indexOf("o")>-1)
                    ? "outlier_pt residual_pt"
                    : "normal_pt residual_pt";
            });
        svgE.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", function(d) {
                return (d.flag_east.indexOf("o")>-1) ? 0 : 3.0;
            })
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yE(d.res_east * 1000);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", "red")
            .attr("class", function(d) {
                return (d.flag_east.indexOf("o")>-1)
                    ? "outlier_pt residual_pt"
                    : "normal_pt residual_pt";
            });
        svgU.selectAll(".dot")
            .data(pdata)
          .enter().append("circle")
            .attr("r", function(d) {
                return (d.flag_up.indexOf("o")>-1) ? 0 : 3.0;
            })
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yU(d.res_up * 1000);})
            .attr("stroke", "blue")
            .attr("stroke-width", 0.3)
            .attr("fill", "red")
            .attr("class", function(d) {
                return (d.flag_up.indexOf("o")>-1)
                    ? "outlier_pt residual_pt"
                    : "normal_pt residual_pt";
            });
        
    });
    // check/uncheck buttons button
    document.getElementById("outlier-btn").checked = false;
    document.getElementById("model-btn").checked   = false;
    // document.getElementById("events-btn").checked  = true;
    // disable outlier button
    document.getElementById("outlier-btn").disabled = true;
    document.getElementById("model-btn").disabled = true;
}

/*
** This function will:
** 1. Remove all points (on all three svg's) tha belong to the 'outlier_pt'
**    class
** 2. Rescale the y-axis (to not include the above points)
** 3. Re-scale and re-plot all points belonging to the 'normal_pt' class
*/
function plot_raw_no_outliers() {

    if ( document.getElementById("outlier-btn").checked === false ) {
        svgN.selectAll(".data_pt").remove();
        svgE.selectAll(".data_pt").remove();
        svgU.selectAll(".data_pt").remove();
        plot_raw();
        return;
    }

    // Get the data again
    d3.json('tuc2.json', function(error, data) {
        if ( error ) throw error;
        pdata = data.data;

        // set x and y domains
        x.domain(d3.extent (pdata, function(d) { return d.epoch; }));
        yN.domain([0, 0]);
        yE.domain([0, 0]);
        yU.domain([0, 0]);
        yN.domain(d3.extent(pdata, function(d) {
            return (d.flag_north.indexOf("o")>-1) ? 0 : d.north;
        }));
        yE.domain(d3.extent(pdata, function(d) { 
            return (d.flag_east.indexOf("o")>-1) ? 0 : d.east;
        }));
        yU.domain(d3.extent(pdata, function(d) { 
            return (d.flag_up.indexOf("o")>-1) ? 0 : d.up;
        }));
        
        // rescale y-axis
        svgN.selectAll(".y.axis").call(yAxisN);
        svgE.selectAll(".y.axis").call(yAxisE);
        svgU.selectAll(".y.axis").call(yAxisU);
    
        // remove points that belong to the 'outlier_pt' class
        svgN.selectAll(".outlier_pt").remove();
        svgE.selectAll(".outlier_pt").remove();
        svgU.selectAll(".outlier_pt").remove();
        
        // re-scale points that belong to the 'normal_pt' class
        svgN.selectAll(".data_pt")
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yN(d.north);});
        svgE.selectAll(".data_pt")
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yE(d.east);});
        svgU.selectAll(".data_pt")
            .attr("cx", function(d) {return x(d.epoch);})
            .attr("cy", function(d) {return yU(d.up);});
            
        // if we also have the model lines, we need to rescale them!
        if ( svgN.select(".model_line").empty() ) {
            console.log("empty selection");
        } else {
            console.log("rescaling model lines");
            // store model points here
            var xdata, ydata, zdata;
            // Get the data
            d3.json('model.json', function(error, data) {
                if ( error ) throw error;
                
                // compute the model points/canvas
                xdata = make_model(data.model_x, g_min_mjd, g_max_mjd, 1);
                ydata = make_model(data.model_y, g_min_mjd, g_max_mjd, 1);
                zdata = make_model(data.model_z, g_min_mjd, g_max_mjd, 1);

                // re-scale the model-line (if any)
                svgN.select(".model_line").attr("d", nline(xdata));
                svgE.select(".model_line").attr("d", eline(ydata));
                svgU.select(".model_line").attr("d", uline(zdata));
            });
        }
    });
}

/*
** Given a "model" object (as read off from a corrsponding json file),
** compute the values of the model for values in
** range [from,to] with a step = step.
** The values are returned as an array of objects of type:
** [...{"t":...,"val":...}...] so that they can be ploted via the [neu]line
** functions
*/
function make_model(mod, from, to, step)
{
    var data = [];
    var value = 0;
    var ref_t = mod.reference_epoch;

    for (var t = from; t <= to; t += step) {
        var dt = t - ref_t;
        value  = mod.const_term;
        value += mod.velocity*dt/365.25;
        for (var comp in mod.harmonics) {
            if (t>=mod.harmonics[comp].from && t<mod.harmonics[comp].to)
            {
                var angular_frequency = 2*Math.PI/mod.harmonics[comp].period;
                value += mod.harmonics[comp].in_phase*Math.cos(angular_frequency*dt);
                value += mod.harmonics[comp].out_of_phase*Math.sin(angular_frequency*dt);
            }
        }
        for (var comp in mod.jumps) {
            if (t>=mod.jumps[comp].at) {
                value += mod.jumps[comp].value;
            }
        }
        data.push({"t":t, "val":value});
    }
    return data;
}

function remove_models()
{
    svgN.selectAll(".model_line").remove();
    svgE.selectAll(".model_line").remove();
    svgU.selectAll(".model_line").remove();
}
/*
** Read coordinate time-series model(s) off from a corresponding json file,
** and plot the models (one per component). The plotted lines will belong to a
** class(es) named "line model_line"
*/
function plot_models()
{
    if ( document.getElementById("model-btn").checked === false ) {
        remove_models();
        return;
    }

    // store model points here
    var xdata, ydata, zdata;
    
    // Get the data
    d3.json('model.json', function(error, data) {
        if ( error ) throw error;
        
        // compute the model points/canvas
        xdata = make_model(data.model_x, g_min_mjd, g_max_mjd, 1);
        ydata = make_model(data.model_y, g_min_mjd, g_max_mjd, 1);
        zdata = make_model(data.model_z, g_min_mjd, g_max_mjd, 1);
        
        // make model a list of strings
        xmodel = data.model_x;
        ymodel = data.model_y;
        zmodel = data.model_z;
        xstr = model2text(xmodel);
        ystr = model2text(ymodel);
        zstr = model2text(zmodel);

        // Define the div for the tooltip, see http://bl.ocks.org/d3noob/a22c42db65eb00d4e369
        var tooltip_div = d3.select("body").append("div")   
                            .attr("class", "model-tooltip")               
                            .style("opacity", 0);

        // append the model as line
        svgN.append("path")
            .datum(xdata)
            .attr("class", "line model_line")
            .attr("d", nline)
            .on("mouseover", function(d) {
                tooltip_div.transition()
                           .duration(200)
                           .style("opacity", .9);
                tooltip_div.html(xstr)
                           .style("left", (d3.event.pageX) + "px")
                           .style("top", (d3.event.pageY - 28) + "px");
            })
            .on("mouseout", function(d) {
                tooltip_div.transition()
                           .duration(200)
                           .style("opacity", 0);
            });
        svgE.append("path")
            .datum(ydata)
            .attr("class", "line model_line")
            .attr("d", eline)
            .on("mouseover", function(d) {
                tooltip_div.transition()
                           .duration(200)
                           .style("opacity", .9);
                tooltip_div.html(ystr)
                           .style("left", (d3.event.pageX) + "px")
                           .style("top", (d3.event.pageY - 28) + "px");
            })
            .on("mouseout", function(d) {
                tooltip_div.transition()
                           .duration(200)
                           .style("opacity", 0);
            });
        svgU.append("path")
            .datum(zdata)
            .attr("class", "line model_line")
            .attr("d", uline)
            .on("mouseover", function(d) {
                tooltip_div.transition()
                           .duration(200)
                           .style("opacity", .9);
                tooltip_div.html(zstr)
                           .style("left", (d3.event.pageX) + "px")
                           .style("top", (d3.event.pageY - 28) + "px");
            })
            .on("mouseout", function(d) {
                tooltip_div.transition()
                           .duration(200)
                           .style("opacity", 0);
            });
    });
}

function model2text(model)
{
    /* As string with newlines
       ------------------------
    var str = 'Reference Epoch: ';
    str += mjd_to_ymdhms(model.reference_epoch) + '\n';
    str += 'Velocity       : ';
    str += model.velocity + ' m/yr\n';
    for (var i in model.harmonics) {
        str += 'Period         : ' + model.harmonics[i].period;
        str += '\n  In Phase     : ' + model.harmonics[i].in_phase + ' (m)';
        str += '\n  Out Of Phase : ' + model.harmonics[i].out_of_phase + ' (m)';
    }
    for (var i in model.jumps) {
        str += '\nJump           : ' + model.jumps[i].value + ' (m) at ' + mjd_to_ymdhms(model.jumps[i].at);
    }
    return str;
    */
    /* As list of strings (lines)
       ----------------------------
    var line_list = [];
    line_list.push('Reference Epoch: ' + mjd_to_ymdhms(model.reference_epoch) + '\n');
    line_list.push('Velocity       : ' + model.velocity + ' m/yr\n');
    for (var i in model.harmonics) {
        line_list.push('Period         : ' + model.harmonics[i].period);
        line_list.push('  In Phase     : ' + model.harmonics[i].in_phase + ' (m)');
        line_list.push('  Out Of Phase : ' + model.harmonics[i].out_of_phase + ' (m)');
    }
    for (var i in model.jumps) {
        line_list.push('Jump           : ' + model.jumps[i].value + ' (m) at ' + mjd_to_ymdhms(model.jumps[i].at));
    }
    return line_list;
    */
    var str = "";
    str += '<p>Reference Epoch: ';
    str += mjd_to_ymdhms(model.reference_epoch) + '</p>';
    str += '<p>Velocity       : ';
    str += model.velocity + ' m/yr</p>';
    for (var i in model.harmonics) {
        str += '<p>Period         : ' + model.harmonics[i].period;
        str += '<br>  In Phase     : ' + model.harmonics[i].in_phase + ' (m)';
        str += '<br>  Out Of Phase : ' + model.harmonics[i].out_of_phase + ' (m)</p>';
    }
    for (var i in model.jumps) {
        str += '<p>Jump           : ' + model.jumps[i].value + ' (m) at ' + mjd_to_ymdhms(model.jumps[i].at)+"</p>";
    }
    return str;
}
/*
function show_model_info()
{
    // Get the data
    d3.json('model.json', function(error, data) {
        if ( error ) throw error;

        xmodel = data.model_x;
        ymodel = data.model_y;
        zmodel = data.model_z;

        xstr = model2text(xmodel);
        var start_x, start_y;
        for (var i in xstr) {
            svgN.append("text")
                .attr("class", "model_text")
                .attr("x", x(start_x))
                .attr("y", yN(start_y))
                .text(xstr[i]);
            start_y -= 0.001;
        }
        //console.log(xstr);
    });
}
*/

function remove_events()
{
    svgN.selectAll(".event_line").remove();
    svgE.selectAll(".event_line").remove();
    svgU.selectAll(".event_line").remove();
}
function plot_events()
{
    if ( document.getElementById("events-btn").checked === false ) {
        remove_events();
        return;
    }

    // Get the data
    d3.json('events.json', function(error, data) {
        if ( error ) throw error;
        
        // split events
        jump_list   = data.jumps;
        velchg_list = data.velocity_changes;
        erthqk_list = data.earthquakes;

        for (var evnt in jump_list) {
            var t  = jump_list[evnt].at;
            svgN.append("line")
                .attr("x1", x(t))
                .attr("y1", yN(yAxisN.scale().domain()[0]))
                .attr("x2", x(t))
                .attr("y2", yN(yAxisN.scale().domain()[1]))
                .attr("class", "event_line jump_line");
            svgE.append("line")
                .attr("x1", x(t))
                .attr("y1", yE(yAxisE.scale().domain()[0]))
                .attr("x2", x(t))
                .attr("y2", yE(yAxisE.scale().domain()[1]))
                .attr("class", "event_line jump_line");
            svgU.append("line")
                .attr("x1", x(t))
                .attr("y1", yU(yAxisU.scale().domain()[0]))
                .attr("x2", x(t))
                .attr("y2", yU(yAxisU.scale().domain()[1]))
                .attr("class", "event_line jump_line");
        }
        
        for (var evnt in velchg_list) {
            var t  = jump_list[evnt].at;
            svgN.append("line")
                .attr("x1", x(t))
                .attr("y1", yN(yAxisN.scale().domain()[0]))
                .attr("x2", x(t))
                .attr("y2", yN(yAxisN.scale().domain()[1]))
                .attr("class", "event_line velchg_line");
            svgE.append("line")
                .attr("x1", x(t))
                .attr("y1", yE(yAxisE.scale().domain()[0]))
                .attr("x2", x(t))
                .attr("y2", yE(yAxisE.scale().domain()[1]))
                .attr("class", "event_line velchg_line");
            svgU.append("line")
                .attr("x1", x(t))
                .attr("y1", yU(yAxisU.scale().domain()[0]))
                .attr("x2", x(t))
                .attr("y2", yU(yAxisU.scale().domain()[1]))
                .attr("class", "event_line velchg_line");
        }
        for (var evnt in erthqk_list) {
            var t  = jump_list[evnt].at;
            svgN.append("line")
                .attr("x1", x(t))
                .attr("y1", yN(yAxisN.scale().domain()[0]))
                .attr("x2", x(t))
                .attr("y2", yN(yAxisN.scale().domain()[1]))
                .attr("class", "event_line erthqk_line");
            svgE.append("line")
                .attr("x1", x(t))
                .attr("y1", yE(yAxisE.scale().domain()[0]))
                .attr("x2", x(t))
                .attr("y2", yE(yAxisE.scale().domain()[1]))
                .attr("class", "event_line erthqk_line");
            svgU.append("line")
                .attr("x1", x(t))
                .attr("y1", yU(yAxisU.scale().domain()[0]))
                .attr("x2", x(t))
                .attr("y2", yU(yAxisU.scale().domain()[1]))
                .attr("class", "event_line erthqk_line");
        }
    });
}

/*
** Attach the x axis to a datetime scale in the domain [g_min_mjd,g_max_mjd]
** Note that nothing gets reploted!
*/
function to_ymdhms()
{
    x = d3.scaleTime().range([0, width]);
    min_ymd = mjd_to_ymdhms(g_min_mjd);
    max_ymd = mjd_to_ymdhms(g_max_mjd);
    // console.log("Min date:", min_ymd);
    // console.log("Max date:", max_ymd);
    x.domain([dateFormat.parse(min_ymd), dateFormat.parse(max_ymd)]);
    xAxis  = d3.axisBottom(x);
    
    // rescale x-axis
    svgN.selectAll(".x.axis").call(xAxis);
    svgE.selectAll(".x.axis").call(xAxis);
    svgU.selectAll(".x.axis").call(xAxis);
}
/*
** Attach the x axis to a datetime scale in the domain [g_min_mjd,g_max_mjd]
** Note that nothing gets reploted!
*/
function to_mjd()
{
    x = d3.scaleLinear().range([0, width]); // v4.x
    x.domain([g_min_mjd, g_max_mjd]);
    xAxis  = d3.axisBottom(x);
    
    // rescale x-axis
    svgN.selectAll(".x.axis").call(xAxis);
    svgE.selectAll(".x.axis").call(xAxis);
    svgU.selectAll(".x.axis").call(xAxis);
}
function to_gpsw()
{
    x = d3.scaleLinear().range([0, width]); // v4.x
    x.domain([mjd_to_gps(g_min_mjd), mjd_to_gps(g_max_mjd)]);
    xAxis  = d3.axisBottom(x);
    
    // rescale x-axis
    svgN.selectAll(".x.axis").call(xAxis);
    svgE.selectAll(".x.axis").call(xAxis);
    svgU.selectAll(".x.axis").call(xAxis);
}
</script>

</body>
</html>
